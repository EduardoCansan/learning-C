ENTENDENDO C:

aula 54

FILES:

FILE *arq -> aponta para um arquivo
fopne -> funcao para abrir arquivo
w -> abrir um arquivo para escrita (se ja existe, é sobreescito por um vazio)
r -> abrir arquivo para leitura (mas não pode escrever nele)
a -> abrir arquivo para adicionar conteudo (se ja existe, é adicionado abaixo do conteudo)

arq = fopen("arquivo.txt", "w"); -> escrive no arquivo

EOF -> end of file
feof -> file end of file

fclose(arq); -> importante fazer isso para que não de problema


----------------------------------------------------------------------------------------------


Struct --> revisar
Union --> é pra economizar, só pega o tamanho da maior posição
Enum --> é tipo um dicionario, suas variaveis só podem acessar o que foi setado ali dentro


----------------------------------------------------------------------------------------------


<stdio.h> --> acesso a arquivos:
    PRINCIPAIS:
    - fclose() = fecha arquivos
    - fflush() = limpa o buffer, corrige um erro (windows + eclipse + c)
    - fopen() = abre um arquivo
    - fscanf() = lê dados formatados de um arquivo
    - printf() = imprime no terminak
    - scanf() = escreve com teclado 
    - gets() = lê um caractere de um arquivo
    - fputs() = escreve um caractere/string em um arquivo
    - getchar() = lê um caractere da entrada padrão
    - fgets() = lê uma string da entrada padrão
    - feof() = quando chega ao fim do arquivo
    - FILE = tipo de dados que abre arquivo
    - EOF = tipo até chegar ao fim do arquivo
    - NULL = pode usar para anular algo

<stdlib.h>
    PRINCIPAIS:
    - atof() = converte string para double
    - atoi() = converte string para inteiro
    - atol() = converte string para long
    - rand() = gera número aleatório
    - srand() = inicializa o gerador de números aleatórios (se nao usar esse ele gera sempre os mesmos numero aleatorios)
    - malloc() = alocação de memória;
    - calloc() = alocação de memória, zera o espaço;
    - free() = libera memória, desalocação de memória
    - realoc() = modifica o tamanho do espaço alocado em memória
    - qsort() = ordena os elementos de um array
    - abs() = valor absoluto
    - div() = divisão inteira

<math.h>
    PRINCIPAIS:
    - cos() = calcula o cosseno de um ângulo em radianos
    - sin() = calcula o seno de um ângulo em radianos
    - tan() = calcula a tangente de um ângulo em radianos
    - cosh() = calcula o cosseno hiperbólico de um ângulo em radianos
    - sinh() = calcula o seno hiperbólico de um ângulo em radianos
    - tanh() = calcula a tangente hiperbólica de um ângulo em radianos
    - exp() = calculo de exponencial
    - log() = calcula o logaritimo natural
    - log10() = calcula o logaritimo base 10
    - pow() = calcula o exponencial
    - sqrt() = calcula a raiz quadrada
    - ceil() = arredonta um numero para cima
    - floor() = arredonta um numero para baixo

<ctype.h>
    PRINCIPAIS: 
    - isalnum() = verifica se o caractere é alfanúmerico
    - isalpha() = verifica se o caractere é alfabético
    - isdigit() = verifica se o caractere é um dígito decimal
    - ispunct() = verifica se o caractere é uma pontuacao
    - isspace() = verifica se é um espaço em branco
    - isupper() = verifica se o caractere é maisculo
    - islower() = verifica se o caractere é minusculo
    - tolower() = converte o caractere para minusculo
    - toupper() = converte o caractere para maisculo

<string.h>
    PRINCIPAIS:
    - strcpy() = realiza a cópia de uma string
    - strcat() = concatena strings
    - strcmp() = compara duas strings
    - strchr() = localiza a primeira ocorrencia de caractere em uma string
    - strtok() = dividir uma string em substrings com base em um caractere
    - strlen() = retorna o tamanho da string

<time.h>
    PRINCIPAIS:
    - clock() = retorna o numero de pulsos de clock decorrido desde o inicio do programa
    - time() = retorna o tempo atual do calendário
    - localtime() = converte o valor time para uma hora localiza 
    - asctime() = converte um valor de tempo para o formato: Dia da semana, Dia do mês Mês Ano Hora:Minuto:Segundo GMT


----------------------------------------------------------------------------------------------------------------------

int *p, qtd;

malloc:
    p = (int*)malloc(qnt *sizeof (int)); 

calloc:
    p = (int*)malloc(qnt, sizeof (int));

realloc:
    p = (int*)malloc(p, qnt * sizeof (int));


BOA PRÁTICA: 
    free(p);
    p = NULL;


PONTEIRO: https://www.treinaweb.com.br/blog/ponteiros-em-c-uma-abordagem-basica-e-inicial






Na linguagem C:

- `0` é considerado **FALSO** (`false`)
- Qualquer valor diferente de `0` é considerado **VERDADEIRO** (`true`)

---

## Tabela ASCII

A **Tabela ASCII** é um sistema de representação de caracteres onde **números inteiros são associados a símbolos**. Por exemplo:

| Símbolo | Código ASCII |
|---------|---------------|
| A       | 65            |
| a       | 97            |
| 0       | 48            |
| Espaço  | 32            |

---

## Strings em C

Para criar uma string em C, utiliza-se um array de caracteres:

```c
char nome[50] ;
```

Aqui determinados os numeros de caracteres, aqui temos 49.<br>
Por que 49? Um dos valores fica reservado para `/0` -> conta como 1

8 bits - 1 byte<br>
16 bits - 2 bytes<br>
24 bits - 3 bytes<br>
. . . 

---

## Função Main()

O int main() é uma função. o `return 0` retorna um inteiro que significa verdadeiro no boolean, como podemos observar, se tiver qualquer outro retorno dara um erro e o programa não conseguirá rodar.

```c
int main() {

    return 0;
}
```

---

## Protótipo da Função

Uma coisa que eu cuido muito nos meus códigos é deixar ele fácil para a leitura, uma técnica boa de ter usada no C é o próprio `protótipo da função`. Onde, primeiros declaramos as funções em cima do `int main()` vamos usar, e logo abaixo nós colocamos a lógica dela. Aqui temos um exemplo:

```c
void saudacao(); // Protótipo

int main() {
    saudacao();
    return 0;
}

void saudacao() { // Lógica
    printf("Olá!\n");
}
```

---

## Criando bibliotecas próprias

Bibliotecas personalizadas são compostas por duas coisas:
- arquivo de cabeçalho(`.h`) - contém protótipos de funções, definições de tipos e constantes.
- Um arquivo de código-fonte (`.c`) – contém a implementação das funções declaradas no `.h`.

<br>Arquivo de Cabeçalho (`ajuda.h`)

```c
void mensagem();
```
Arquivo de Código-Fonte(`ajuda.c`)

```c
void mensagem() {
    prinft("Bem vindo...\n");
};
```

Arquivo main(`main.c`)
```c
#include <ajuda.h>

int main() {
    menasgem();
    return 0;
}
```
---

## Sobre Ponteiros e Endereçamento de Memória

Ao utilizar scanf, passamos o endereço da variável usando o operador `&`. Isso armazena o valor lido diretamente no local de memória da variável. Esse valor pode ser resgatado e utilizado posteriormente com um loop, por exemplo.

```c
int idade;
scanf("%d", &idade);
```

Ponteiros são variáveis que armazenam endereços de memória. Exemplo:

```c
int x = 10;
int *p = &x;

printf("Endereço de x: %p\n", &x);
printf("Valor de p (endereço que p aponta): %p\n", p);
printf("Endereço de p: %p\n", &p);

```

| Conceito | O que representa |
|----------|------------------|
| Endereço de memória        | 	Onde uma variável comum está armazenada                   |
| Endereço de ponteiro	     | Onde a variável ponteiro (que guarda endereços) está armazenada            


--- 

### 7. MemoryAllocation

Aloca um pedaço de memória sem limpar. Você precisa dizer o tamanho em bytes. 
Depois, você usa esse espaço como quiser. Se não usar free, dá vazamento.
MALLOC => aloca um bloco de memória não inicializado.

Aloca memória e já preenche tudo com zero. Você informa quantos blocos e o tamanho de cada um (ex.: 5 números inteiros).
Útil quando quer ter certeza que a memória começa limpa.
CALLOC => útil quando você quer garantir que toda memória comece limpa.

Aumenta ou diminui o tamanho de um pedaço de memória já alocado. Se aumentar, os novos espaços não vêm zerados. 
Se não tiver espaço para crescer ali, ele move a memória para outro lugar (por isso o ponteiro pode mudar).

REALLOC => O realloc pode mover a memória para um novo local se necessário. Sempre cheque se o ponteiro não virou NULL depois!